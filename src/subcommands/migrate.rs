use std::{sync::Arc, time::Instant};

use casper_execution_engine::storage::{
    global_state::lmdb::LmdbGlobalState, trie_store::lmdb::LmdbTrieStore,
};
use casper_hashing::Digest;
use clap::{Arg, ArgMatches, Command};

use crate::common::execution_engine::create_lmdb_environment;

pub const COMMAND_NAME: &str = "migrate";
const DB_PATH: &str = "file-path";
const MAX_DB_SIZE: &str = "max-db-size";
const STATE_ROOT_HASH: &str = "state-root-hash";
const DEFAULT_MAX_DB_SIZE: usize = 483_183_820_800; // 450 gb

pub fn command(display_order: usize) -> Command<'static> {
    Command::new(COMMAND_NAME)
        .display_order(display_order)
        .about(
            "Reduces the disk size of an LMDB database generated by a Casper node by removing \
            empty blocks of the sparse file.",
        )
        .arg(
            Arg::new(DB_PATH)
                // .display_order(0)
                .value_name("DB_PATH")
                .required(true)
                .help("Path to the storage.lmdb or data.lmdb file."),
        )
        .arg(
            Arg::new(STATE_ROOT_HASH)
                // .display_order(0)
                .value_name("STATE_ROOT_HASH")
                .required(true)
                .help("State root hash of the tip of the trie."),
        )
        .arg(
            Arg::new("BATCH_SIZE")
                .long("--batch-size")
                .value_name("BATCH_SIZE")
                .required(true)
                .help("State root hash of the tip of the trie."),
        )
}

pub fn run(matches: &ArgMatches) -> bool {
    let db_path = matches.value_of(DB_PATH).unwrap();
    let state_root_hash = matches.value_of(STATE_ROOT_HASH).unwrap();
    let state_root_hash = Digest::from_hex(state_root_hash).unwrap();
    let batch_size:usize = matches.value_of("BATCH_SIZE").unwrap().parse().unwrap();
    let lmdb_environment = create_lmdb_environment(&db_path, DEFAULT_MAX_DB_SIZE, true)
        .expect("create lmdb environment");
    let lmdb_trie_store = Arc::new(LmdbTrieStore::open(&lmdb_environment, None).unwrap());

    let (empty_root_hash, _empty_trie) =
        casper_execution_engine::storage::global_state::lmdb::compute_empty_root_hash().unwrap();
    let global_state = LmdbGlobalState::new(
        Arc::clone(&lmdb_environment),
        lmdb_trie_store,
        empty_root_hash,
    );

    let start = Instant::now();
    let result = casper_execution_engine::core::engine_state::upgrade::migrations::purge_era_info(
        &global_state,
        state_root_hash,
        batch_size,
    );
    let elapsed = start.elapsed();

    match result {
        Ok(migration_result) => {
            if migration_result.post_state_hash == state_root_hash {
                println!("(!) No migration was performed.");
            } else {
                println!("Migration finished in {:?}", elapsed);
            }
            println!("Keys deleted: {}", migration_result.keys_to_delete.len());
            println!(
                "Firt deleted key: {:?}",
                migration_result.keys_to_delete.first()
            );
            println!(
                "Last deleted key: {:?}",
                migration_result.keys_to_delete.last()
            );
            // println!("Last era info: {:?}", migration_result.era_summary);
            println!(
                "State root hash after migration: {}",
                migration_result.post_state_hash
            );
            true
        }
        Err(error) => {
            eprintln!("Error while running migration: {error}");
            false
        }
    }

    // let execution_engine = load_execution_engine
    // let ee = utils::load_execution_engine
    // load_execution_engine(ee_lmdb_path, default_max_db_size, state_root_hash, manual_sync_enabled)
    // let path = Path::new(matches.value_of(DB_PATH).expect("should have db-path arg"));
    // let output = matches.value_of(OUTPUT).map(Path::new);
    // let result = read_db::latest_block_summary(path, output);

    // if let Err(error) = &result {
    //     error!("Latest block summary failed. {}", error);
    // }

    // result.is_ok()
}

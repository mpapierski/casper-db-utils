use std::{sync::Arc, time::Instant, rc::Rc, cell::RefCell};

use casper_execution_engine::{
    core::engine_state::{
        // purge::{PurgeConfig, PurgeResult},
        EngineConfig, EngineState,
    },
    shared::newtypes::CorrelationId,
    storage::{global_state::lmdb::LmdbGlobalState, trie_store::lmdb::LmdbTrieStore, trie::Trie},
};
use casper_hashing::Digest;
use casper_types::{EraId, Key, StoredValue, bytesrepr::{ToBytes, self}, ContractHash};
use clap::{Arg, ArgMatches, Command};

use crate::common::execution_engine::{create_lmdb_environment, DEFAULT_MAX_READERS};

pub const COMMAND_NAME: &str = "migrate";
const DB_PATH: &str = "file-path";
const _MAX_DB_SIZE: &str = "max-db-size";
const STATE_ROOT_HASH: &str = "state-root-hash";
// const STATE_ROOT_HASH: &str = "state-root-hash";
const DEFAULT_MAX_DB_SIZE: usize = 483_183_820_800; // 450 gb

pub fn command(_display_order: usize) -> Command<'static> {
    Command::new(COMMAND_NAME)
        .about(
            "Reduces the disk size of an LMDB database generated by a Casper node by removing \
            empty blocks of the sparse file.",
        )
        .arg(
            Arg::new(DB_PATH)
                .value_name("DB_PATH")
                .required(true)
                .help("Path to the storage.lmdb or data.lmdb file."),
        )
        .arg(
            Arg::new(STATE_ROOT_HASH)
                .value_name("STATE_ROOT_HASH")
                .required(true)
                .help("State root hash of the tip of the trie."),
        )
        .arg(
            Arg::new("auction-contract")
                .takes_value(true)
                .long("--auction-contract")
                .help("Hash of an auction contract")
                .default_value("ccb576d6ce6dec84a551e48f0d0b7af89ddba44c7390b690036257a04a3ae9ea")
        )

}
pub fn create_hashed_empty_trie<K: ToBytes, V: ToBytes>(
) -> Result<(Digest, Trie<K, V>), bytesrepr::Error> {
    let root: Trie<K, V> = Trie::Node {
        pointer_block: Default::default(),
    };
    let root_bytes: Vec<u8> = root.to_bytes()?;
    Ok((Digest::hash(root_bytes), root))
}
pub fn run(matches: &ArgMatches) -> bool {
    let db_path = matches.value_of(DB_PATH).unwrap();
    let state_root_hash = matches.value_of(STATE_ROOT_HASH).unwrap();
    let mut state_root_hash = Digest::from_hex(state_root_hash).unwrap();

    let auction_hash = matches.value_of("auction-contract").unwrap();
    let auction_hash = Digest::from_hex(auction_hash).unwrap();
    let auction_contract_hash = ContractHash::new(auction_hash.value());

    let lmdb_environment = create_lmdb_environment(&db_path, DEFAULT_MAX_DB_SIZE, DEFAULT_MAX_READERS, true)
        .expect("create lmdb environment");

    let (empty_root_hash, _root) = create_hashed_empty_trie::<Key, StoredValue>().unwrap();

    let lmdb_trie_store = Arc::new(LmdbTrieStore::open(&lmdb_environment, None).unwrap());

    let global_state = LmdbGlobalState::new(
        Arc::clone(&lmdb_environment),
        lmdb_trie_store,
        empty_root_hash,
    );


    let state = EngineState::new(global_state, EngineConfig::default());

    let tc = Rc::new(RefCell::new(state.tracking_copy(state_root_hash).expect("should work").expect("should have state")));
    let res = casper_execution_engine::core::engine_state::migrate_withdraw_to_unbonding::<LmdbGlobalState>(&tc, CorrelationId::new(), &auction_contract_hash);
    println!("result={:?}", res);

    true
}
